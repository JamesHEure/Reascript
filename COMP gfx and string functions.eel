//beginf color functions 
function setcolor(hex)
  ( gfx_r= ((hex>>16)&255)/255; gfx_g= ((hex>>8)&255)/255; gfx_b= (hex>>0&255)/255;  );
function setcolor(hex,a)
  ( setcolor(hex); gfx_a=a/255; );  
function setcolor(r,g,b) 
  ( gfx_r=r/255; gfx_g=g/255; gfx_b=b/255; );
function setcolor(r,g,b,a)
  ( setcolor(r,g,b); gfx_a=a/255 );
  
function pack_rgb()
  (!gfx_b?gfx_b+=.001;(((gfx_b*255)+(gfx_g*255)*256+(gfx_r*255)*65536)););
function pack_rgb(r,g,b)
  (!b?b+=.001;( (b*255) + (g*255)*256 + (r*255)*65536);); 
function unpack_r(pack)
  (((pack>>16)&255)/255);
function unpack_g(pack)
  (((pack>>8)&255)/255);
function unpack_b(pack)
  ((((pack&255))/255));
function unpack_rgb() local(r,g,b)
  (gfx_r=unpack_r(pack_rgb()); gfx_g=unpack_g(pack_rgb()); gfx_b=unpack_b(pack_rgb()); );
//endf

//beginf x,y                                                                              
function xymask(x,y)
  ( x+y*max(gfx_w,gfx_h); ); //used in was_drag, etc
function _xy(x,y)  //sets gfx_x, gfx_y. returns a packed value 
  ( gfx_x=x; gfx_y=y; xymask(x,y));
function _gfx_sizecache()
 (_gfx_sizecache=gfx_w+gfx_h*256; _gfx_sizecache;);
function return_gfxsize()
 (gfx_w+gfx_h*256;);   
  
//unfinished outline for a xywh table  
function __init_xywh(ux,uy,uw,uh)//instance(x,y,w,h,init)
  ( !this..init  ? (this..x=ux; this..y=uy; this..w=uw; this..h=uh; this..init=1;); );
function _init_xywh(ux,uy,uw,uh)instance(x,y,w,h,init)
  ( !init  ? (x=ux; y=uy; w=uw; h=uh; init=1;); );  
//endf                                                                                                      

//beginf MOUSE                                           
function mouse_in_rect(x,y,w,h)//return 1 if yes, 0 if no
  (  mouse_x > x && mouse_x < (x+w) && mouse_y > y && mouse_y < (y+h)  ? 1 : 0; );//
//When using with mouse_in_rect, click areas must not overlap.
// to have an overlaping area use _instance version, or create a function specific version
// i.e. __xon_mouse_click(cap) and __toggle_mouse_click(cap) can be used on the same object
function mouse_click(cap)local(i) 
  (mouse_cap == cap ? i+=1: i=0; i == 1 ? 1 : 0;);
function mouse_dblclick (cap)local(i,ii)//to create a double click trigger
  (mouse_cap==cap && !_gfx_drag ? (i+=1; i==1 ? ii+=5): (i=0; ii > 0 ? ii-=1); ii >= 6 ? 1:0;);
function mouse_dblclick (cap,speed)local(i,ii)//sets speed
  (mouse_cap==cap ? (i+=1; i==1 ? ii+=speed): (i=0; ii > 0 ? ii-=1); ii >= speed+1 ? 1:0;);
  
  
function mouse_click_i(cap)instance(i) 
  (mouse_cap == cap ? i+=1: i=0; i == 1 ? 1 : 0;);
function mouse_dblclick_i (cap)instance(i,ii)//to create a double click trigger
  (mouse_cap==cap && !_gfx_drag ? (i+=1; i==1 ? ii+=4): (i=0; ii > 0 ? ii-=1); ii >= 5 ? 1:0;);
function mouse_dblclick_i (cap,speed)instance(i,ii)//sets speed
  (mouse_cap==cap ? (i+=1; i==1 ? ii+=speed): (i=0; ii > 0 ? ii-=1); ii >= speed+1 ? 1:0;);  


function mousein_texth(len)
  ( mouse_in_rect(gfx_x,gfx_y,len,gfx_texth) ? 1:0 );  

function __xon_mouse_click (cap)local(i)(mouse_cap == cap ? i+=1: i=0; i == 1 ? 1 : 0; );
function __xon_mouse_dblclick (cap)local(i,ii,sp)
(mousespeed ? sp=mousespeed: sp=6; mouse_cap==cap ? (i+=1; i==1 ? ii+=sp): (i=0; ii > 0 ? ii-=1); ii >= sp+1 ? (ii=0; 1):0;);

function mouse_in_rect_xon(x,y,w,h,var,onstate,cap) 
  (!_gfx_drag && mouse_in_rect(x,y,w,h) && __xon_mouse_click (cap) ? var!=onstate ? var=onstate; var);  
  function mouse_in_rect_xon(x,y,w,h,var,onstate) (mouse_in_rect_xon(x,y,w,h,var,onstate,1)); 
  function mouse_in_rect_xon_dbl(x,y,w,h,var,onstate,cap) (mouse_in_rect(x,y,w,h) && __xon_mouse_dblclick (cap) ? var!=onstate ? var=onstate; var);
  function mouse_in_rect_xon_dbl(x,y,w,h,var,onstate)(mouse_in_rect_xon_dbl(x,y,w,h,var,onstate,1));

function __toggle_mouseclick(cap)local(i)(mouse_cap == cap ? i+=1: i=0; i == 1 ? 1 : 0; );
function __toggle_mouse_dblclick (cap)local(i,ii,sp) 
  (  mousespeed ? sp=mousespeed: sp=6; mouse_cap==cap ? (i+=1; i==1 ? ii+=sp): (i=0; ii > 0 ? ii-=1); ii >= sp+1 ? (ii=0; 1):0;);
function mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,cap)
  (  !_gfx_drag && mouse_in_rect(x,y,w,h) && __toggle_mouseclick (cap) ? var==onstate ? var=offstate:var=onstate; var;);
  function mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate) (mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,1));
  function mouse_in_rect_toggle(x,y,w,h,var,cap)(mouse_in_rect_toggle(x,y,w,h,var,1,0,cap));
  function mouse_in_rect_toggle(x,y,w,h,var) (mouse_in_rect_toggle(x,y,w,h,var,1,0,1));
  function mouse_in_rect_toggle_dbl(x,y,w,h,var,onstate,offstate,cap)
    (!_gfx_drag && mouse_in_rect(x,y,w,h) && __toggle_mouse_dblclick (cap) ? var==onstate ? var=offstate:var=onstate; var;);
  function mouse_in_rect_toggle_dbl(x,y,w,h,var,onstate,offstate) (mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,1));
  function mouse_in_rect_toggle_dbl(x,y,w,h,var,cap)(mouse_in_rect_toggle(x,y,w,h,var,1,0,cap));
  function mouse_in_rect_toggle_dbl(x,y,w,h,var) (mouse_in_rect_toggle(x,y,w,h,var,1,0,1));  


function mouse_in_string(str)local(w,h)
(
  gfx_measurestr(str,w,h);
  mouse_in_rect(gfx_x,gfx_y,w,h);
); 
 
//subf MOUSE DRAG
function __drag_xaxis(var,cap,inc,spd)local(t,cache_y,cache_x)//local drag cache
  ( mouse_cap==cap && _gfx_drag==xymask(gfx_x,gfx_y)  ? (
      mouse_x< cache_x ? t-=1;  t < -spd ? ( var-=inc; cache_x=mouse_x; t=0; );
      mouse_x> cache_x ? t+=1;  t >  spd ? ( var+=inc; cache_x=mouse_x; t=0; );     
      cache_y=mouse_y; cache_x=mouse_x;     
    ); var;             
  );
  function __drag_xaxis(var,cap1,inc1,cap2,inc2,spd) 
    ( mouse_cap == cap1 ? var=__drag_xaxis(var,cap1,inc1,spd); 
      mouse_cap == cap2 ? var=__drag_xaxis(var,cap2,inc2,spd); var; 
    );
  
   
function __drag_yaxis(var,cap,inc,spd)local(t,cache_y,cache_x)
  ( mouse_cap==cap && _gfx_drag==xymask(gfx_x,gfx_y)  ? (
      mouse_y> cache_y ? t-=1; t < -spd ? ( var-=inc; cache_y=mouse_y; t=0; );
      mouse_y< cache_y ? t+=1; t >  spd ? ( var+=inc; cache_y=mouse_y; t=0; );
      cache_y=mouse_y; cache_x=mouse_x;      
    );
    var;             
  );//
function __drag_yaxis(var,cap1,inc1,cap2,inc2,spd)//2caps
  (
     mouse_cap == cap1 ? var=__drag_yaxis(var,cap1,inc1,spd); 
     mouse_cap == cap2 ? var=__drag_yaxis(var,cap2,inc2,spd);
     var;              
  );




  /*****************************************************************************************
    Use with faders, etc. to prevent other elements from being modified if you drag over
    another element.
  *****************************************************************************************/   
function was_not_was_drag(x,y,w,h,cap1,cap2)local(was_mouse)
  (
    //release wasclicked and wasmouse on button release   
    _gfx_drag==xymask(x,y) && !mouse_cap  ? (_gfx_drag=0; was_mouse=0;);  
    //if mouse is in box and wasmouse is 0, or if box was clicked, set wasmouse
    ( mouse_in_rect(x,y,w,h) && was_mouse!=xymask(x,y) ) || _gfx_drag==xymask(x,y) ? was_mouse=xymask(x,y);
    //if  wasmouse is set and if box is not clicked, set wasdrag
    was_mouse==xymask(x,y) && !_gfx_drag && (mouse_click(cap1) || mouse_click(cap2))  ? _gfx_drag=xymask(x,y);
    //reset was mouse
    was_mouse==xymask(x,y) && !_gfx_drag ? was_mouse=0;  
    //return packed xy val if clicked or if mouse on  
    _gfx_drag==xymask(x,y) || (_gfx_drag && was_mouse==xymask(x,y)) ? xymask(x,y): 0;
  );  
  
function was_not_was_drag(x,y,w,h,cap1)
  (was_not_was_drag(x,y,w,h,cap1,cap1) 
  );//

//OLDER CLICKED VERSION may still be used in some text fields
//Use with text inputboxes, etc to prevent other elements from being modifed while the box is active 
function was_not_was_clicked(x,y,w,h,cap)local(was_mouse,rp)
(
  //!_gfx_clicked? rp=gfx_getchar(); //text overflow bug fix
//set was_mouse (packed x,y) if mouse is in box and was_mouse is not already set                                                                                        
  was_mouse == 0 &&  mouse_in_rect(x,y,w,h) ? was_mouse=xymask(x,y); 
//set was_clicked if clicked     
  was_mouse==xymask(x,y) && mouse_cap==cap ? _gfx_clicked=xymask(x,y);       
//set packed xy val if clicked or if mouse is in box          
  was_mouse==xymask(x,y)|| _gfx_clicked==xymask(x,y) ? was_mouse=xymask(x,y): was_mouse=0; 
//release was_mouse so other boxes can be highlighted on mouse over
  !(mouse_cap&3) ? was_mouse=0; 
//return packed xy val if clicked or if mouse on   
  was_mouse;  
);

function ___was_clicked(x,y,w,h,cap)local(was_mouse)
  (
    //release wasclicked and wasmouse on button release   
    _gfx_clicked==xymask(x,y) && !mouse_cap  ? (_gfx_clicked=0; was_mouse=0;);  
    //set was mouse to mask if mouse is in rectangle of is was clicked already set
    ( mouse_in_rect(x,y,w,h) && was_mouse!=xymask(x,y) ) || _gfx_clicked==xymask(x,y) ? was_mouse=xymask(x,y);
    //if  wasmouse is set and if box is not clicked, set wasclicked on click
    was_mouse==xymask(x,y) && !_gfx_clicked &&  mouse_click(cap)   ? _gfx_clicked=xymask(x,y);
    //reset was mouse
    was_mouse==xymask(x,y) && !_gfx_clicked ? was_mouse=0;  
    //return packed xy val if clicked or if mouse on  
    _gfx_clicked==xymask(x,y) || (_gfx_clicked && was_mouse==xymask(x,y)) ? xymask(x,y): 0;
  ); //assume cap 1
function was_not_was_clicked(x,y,w,h) (was_not_was_clicked(x,y,w,h,1;) );


/*
  
//for manual mouse in logic
function was_not_was_drag(mouse_in)local(was_mouse)
  (
    //release wasclicked and wasmouse on button release   
    !mouse_cap ? (_gfx_drag=0; was_mouse=0;);  
    //if mouse is in box and wasmouse is !, or if box was clicked, set wasmouse
    mouse_in  && (was_mouse!=xymask(gfx_x,gfx_y)) || _gfx_drag==xymask(gfx_x,gfx_y) ? 
    was_mouse=xymask(gfx_x,gfx_y);
    //if  wasmouse is set and if box is not clicked, set wasclicked
    was_mouse==xymask(gfx_x,gfx_y)&& !_gfx_drag && mouse_click(1) ? _gfx_drag=xymask(gfx_x,gfx_y);  
    was_mouse==xymask(gfx_x,gfx_y) && !_gfx_drag ? was_mouse=0;
    //return packed xy val if clicked or if mouse on  
    _gfx_drag==xymask(gfx_x,gfx_y) || (!_gfx_drag && was_mouse==xymask(gfx_x,gfx_y)) ? xymask(gfx_x,gfx_y): 0;
  );//
// 

//***************************************************************************************global mouse drags**/  
function __mouse()//global mouse cache  must call at end of @gfx
  (_gfx_mousecache_y=mouse_y; _gfx_mousecache_x=mouse_x; 
  );
function drag_xaxis(var,xymask,cap,inc,spd)local(t)//global drag
  ( mouse_cap==cap && _gfx_drag==xymask  ? (
      mouse_x< _gfx_mousecache_x ? t-=1; 
      t < -spd ? ( var-=inc; _gfx_mousecache_x=mouse_x; t=0; );
      mouse_x> _gfx_mousecache_x ? t+=1;
      t > spd ? (  var+=inc; _gfx_mousecache_x=mouse_x; t=0; );     
    );
    var;             
  );//
function drag_xaxis(var,xymask,cap1,inc1,cap2,inc2,spd)//2caps
  (
     mouse_cap == cap1 ? var=drag_xaxis(var,xymask,cap1,inc1,spd); 
     mouse_cap == cap2 ? var=drag_xaxis(var,xymask,cap2,inc2,spd);
     var;              
  );//   
function drag_yaxis(var,xymask,cap,inc,spd)local(t)
  ( mouse_cap==cap && _gfx_drag==xymask  ? (
      mouse_y> _gfx_mousecache_y ? t-=1; 
      t < -spd ? ( var-=inc; _gfx_mousecache_y=mouse_y; t=0; );
      mouse_y< _gfx_mousecache_y ? t+=1;
      t > spd ? (  var+=inc; _gfx_mousecache_y=mouse_y; t=0; );     
    );
    var;             
  );//
function drag_yaxis(var,xymask,cap1,inc1,cap2,inc2,spd)//2caps
  (
     mouse_cap == cap1 ? var=drag_yaxis(var,xymask,cap1,inc1,spd); 
     mouse_cap == cap2 ? var=drag_yaxis(var,xymask,cap2,inc2,spd);
     var;              
  );//

//subf other mouse functions

function mouse_countclick(cap)local(i)//used for delayed triggers i.e. mouse_countclick(1)==25? blah=blahblah;
  (mouse_cap == cap ? i+=1 : i=0; i;
  );// 
function mouse_step(cap)local(i)//repeated delayed trigger, uses a default time of 6 for the steps
  (mouse_cap == cap ? (i+=1; i>6 ? i=0 ): i=0; i == 1 ? 1 : 0;
  );// 
function mouse_step(cap,step)local(i)//defines step "speed"
  (mouse_cap == cap ? (i+=1; i>step ? i=0 ): i=0; i == 1 ? 1 : 0;
  );// 
  
//call at end of @gfx*/
function _gfx_refresh_mouse_dblclick (cap)local(i,ii)
  (mouse_cap==cap ? (i+=1; i==1 ? ii+=6): (i=0; ii > 0 ? ii-=1); ii >= 7 ? 1:0;);
function _gfx_refresh() 
  (_gfx_refresh?_gfx_refresh=0; !_gfx_drag && !_gfx_clicked && _gfx_refresh_mouse_dblclick (cap) ? _gfx_refresh=1; ); //use only for de-bugging, etc.

 
//endf

//beginf text functions 

function cr() ( gfx_y+=gfx_texth; );  //Carriage return
function cr(spacing) ( gfx_y+=gfx_texth+spacing);  //Carriage return


//set _was_clicked to -1 @init (in the rare case you want to have an object at 0,0).  
function init_was_clicked() local(init)
  (!init ? (was_clicked=-1; init=1); );  
  
function max_char(max_char)local(w,h)
  (gfx_measurestr("0",w,h); w*max_char);  
  
function text_field(varstr,max_char,field_color)//text color is current color
local(strw,strh,next,i,curoff,curoffw,strh,temp,pr,rp,_1st_click,x,y,set,ww,text_color,set)
//instance(pr)
(
  set=0;
  x=gfx_x; y=gfx_y; 
  ww=max_char(max_char);
  text_color=pack_rgb();//store current color for text
  field_color >=0 ? (
    setcolor(field_color);//set field color. -1 draws no box.
    gfx_rect(x-2,y,ww+4,gfx_texth);
  );  
  setcolor(text_color);  
  mouse_in_rect(x,y,ww,gfx_texth) && mouse_click(1) ? ( 
    was_clicked=xymask(x,y);
    //set=0;
  );  
//Field ACTIVE  !!!
  was_clicked==xymask(x,y) ? ( 
//define temp strings  
     temp=#; curoff=#; 
//at click set next to strlen         
    _1st_click == 0 ? (next=strlen(varstr); _1st_click=1);
//*validate all characters except backspace, ENTER, and arrows           
    pr=gfx_getchar(0);                                                   
     pr && (pr!=8 && pr!=1818584692 && pr!=1919379572 && pr!=13) ? ( 
  //format input to temp  //append input to string  //reset next flag                         
      sprintf(temp, "%c", pr);  strcat(varstr,temp); next=strlen(varstr);                                      
    );    
  /*backspace*/
    pr == 8 ? ( 
    //deincrement next //copy to self 
      next=max(next-=1,0); strcpy_substr(varstr,varstr, 0, next);                
    );       
  /*left arrow*/
    pr == 1818584692 ? (
    //decrease next flag //copy string from next offset (last character) to (new)temp              
      next=max(next-=1,0); strcpy_from(temp=#,varstr,next); 
    //if cursor is already offset, append curoff to temp  //copy last character to curoff                            
      strlen(curoff) ? strcat(temp,curoff); strcpy(curoff, temp); 
    //copy string minus count back to self and reset next                                                                      
      strcpy_substr(varstr,varstr, 0, next); next=strlen(varstr);         
    ); 
  /*right arrow*/
    pr == 1919379572 ? ( 
    //increment next (unless already at end of string)            
      next=min(next+=1,strlen(varstr));
    //if cursor is already offset, append 1st char of curoff to string    
      strlen(curoff) ? strncat(varstr,curoff,1);
    //if the string is not null, copy curroff to self minus 1st char                           
      strlen(varstr) ? strcpy_from(curoff,curoff,1); 
    //reset next             
      next=strlen(varstr);
    ); 
  //measure string for cursor                                              
    gfx_measurestr(varstr,strw,strh); strlen(varstr) == 0 ? strw=0;                            
  //switching ~ every second, draw cursor     
    i+=1; i == 30 ? i=0; i > 15 ? gfx_line(x+strw,y+2,x+strw,y+gfx_texth-2);
  //print string                 
    gfx_printf(varstr);
  //and cursor offset string (if present)                                           
    strlen(curoff) ? gfx_printf(curoff); 
    
    !mouse_in_rect(x,y,ww,gfx_texth) && mouse_cap ?  (
      
      was_clicked==xymask(x,y) ? (
        was_clicked=-1;
        set=1;
      );  
    );
  /*ENTER*/  //exit on ENTER or click outside the box                      
    pr == 13 || was_clicked!=xymask(x,y) || set ? (
      !set ? set=1; 
    //add curoffset string to string //clear the string
      strcat(varstr,curoff); strncpy(curoff,curoff,0);   
    //clear clicked values                             
      _1st_click=0; was_clicked=-1;    
                                    
    );
           
  ):(   
/*if box inactive*/
    was_clicked==-1 ? rp=gfx_getchar(); //text overflow fix
    gfx_printf(varstr);  
    set;                                              
  ); 
  set;
);

// deprecated
//NOTE!!!!!!!!!!!!!!!  need to update this one to use was_clicked!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
//                                                                                                 
function num_field(var,flen,format,varstr)//flen = "field length"
//useage example:  this=text_field(this,txt_w("000"),"%i",_this=#);
//the varstr input, even if a temporary string, prevents having to use instance()
local(strw,strh,next,i,curoff,curoffw,strh,temp,pr,rp,_1st_click,m,x,y,__clicked)
(
  x=gfx_x; y=gfx_y; //m=mouse_in_rect(x,y,flen,gfx_texth);
  //was_not_was_clicked(x,y,flen,gfx_texth);
  mouse_in_rect(x,y,flen,gfx_texth) && mouse_cap==1 ? __clicked=xymask(x,y);
//Field ACTIVE  !!!
  __clicked==xymask(x,y) ? ( 
//define temp strings  
     temp=#; curoff=#; 
//at click set next to strlen         
    _1st_click == 0 ? (format!="%s" ? 
      sprintf(varstr, format, var):
      strcpy(varstr, var);
    
       next=strlen(varstr); _1st_click=1);
//*validate only number inputs + space + decimal, x, comma, minus, A-F *            
    pr=gfx_getchar(0);                                                   
   (pr >= 48 && pr <= 57) || pr == 32 || pr==120 || (pr >=44 && pr <= 46) || (pr>=65 && pr <=70) ? ( 
  //format input to temp  //append input to string  //reset next flag                         
      sprintf(temp, "%c", pr);  strcat(varstr,temp);  next=strlen(varstr);                                      
    );    
  /*backspace*/
    pr == 8 ? ( 
    //deincrement next //copy to self 
      next=max(next-=1,0); strcpy_substr(varstr,varstr, 0, next);                
    );       
  /*left arrow*/
    pr == 1818584692 ? (
    //decrease next flag //copy string from next offset (last character) to (new)temp              
      next=max(next-=1,0); strcpy_from(temp=#,varstr,next); 
    //if cursor is already offset, append curoff to temp  //copy last character to curoff                            
      strlen(curoff) ? strcat(temp,curoff); strcpy(curoff, temp); 
    //copy string minus count back to self and reset next                                                                      
      strcpy_substr(varstr,varstr, 0, next); next=strlen(varstr);         
    ); 
  /*right arrow*/
    pr == 1919379572 ? ( 
    //increment next (unless already at end of string)            
      next=min(next+=1,strlen(varstr));
    //if cursor is already offset, append 1st char of curoff to string    
      strlen(curoff) ? strncat(varstr,curoff,1);
    //if the string is not null, copy curroff to self minus 1st char                           
      strlen(varstr) ? strcpy_from(curoff,curoff,1); 
    //reset next             
      next=strlen(varstr);
    ); 
  //measure string for cursor                                              
    gfx_measurestr(varstr,strw,strh); strlen(varstr) == 0 ? strw=0;                            
  //switching ~ every second, draw cursor     
    i+=1; i == 30 ? i=0; i > 15 ? gfx_line(gfx_x+strw,y+2,gfx_x+strw,y+strh-2);
  //print string                 
    gfx_printf(varstr);
  //and cursor offset string (if present)                                           
    strlen(curoff) ? gfx_printf(curoff); 
  /*ENTER*/  //exit on ENTER or click outside the box                      
    pr == 13 || ( !mouse_in_rect(x,y,flen,gfx_texth) && mouse_cap==1 ) ? (
    //add curoffset string to string //clear the string
      strcat(varstr,curoff);  strncpy(curoff,curoff,0);   
    //clear clicked values                             
      _1st_click=0; __clicked=0;
    //only on ENTER format and set var to string   
      pr==13 ? ( 
          format=="%X" || format=="%s" ?  match(format,varstr,var): 
          match("%f",varstr,var); //sprintf(varstr, format, var););
          __clicked=0; 
      );                                                      
    );         
  ):(   
/*if box inactive*/
  //format and set var to string (tracks external changes //print string
    sprintf(varstr, format, var); gfx_printf(varstr);                                                
  );
  //!was_clicked ? rp=gfx_getchar(); //text overflow bug fix
  //match(format,varstr,var); 
  var;    
);
//                                                                                                    TEXT and STRING functions>

function num_field_cr(var,flen,format,varstr)local(x)
(
  x=gfx_x;
  num_field(var,flen,format,varstr);
  gfx_x=x; cr();
);
//                                                                                                    TEXT and STRING functions>
function get_txt_width(string)local(strw,strh)
  ( gfx_measurestr(string,strw,strh); strw ); //
function txt_w(string)local(strw,strh)//~shorter name~
  ( gfx_measurestr(string,strw,strh); strw ); 

///*print strings, left, center, just  -  gfx_x position retained
function print_leftjust(string)local(_ox)
  ( _ox=gfx_x; gfx_printf(string); gfx_x=_ox; );
function print_rightjust(string)local(_ox)
  ( _ox=gfx_x;  gfx_x=gfx_x-get_txt_width(string); 
    gfx_printf(string); gfx_x=_ox; );
function print_centerjust(string)local(_ox)
  ( _ox=gfx_x; gfx_x=(gfx_x-(get_txt_width(string)/2));  
      gfx_printf(string); gfx_x=_ox; );

function draw_leftjust(string)
  ( gfx_printf(string);  );
function draw_rightjust(string)
  ( gfx_x=gfx_x-get_txt_width(string); 
    gfx_printf(string);  );
function draw_centerjust(string)
  ( gfx_x=(gfx_x-(get_txt_width(string)/2));  
      gfx_printf(string);  );

//                                                                                                    TEXT and STRING functions>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Toggles variable between two values|
function print_leftjust_toggle(string,var,onstate,offstate,cap)local(x,y,w,h,init)
  (x=gfx_x;y=gfx_y;w=txt_w(string);h=gfx_texth;init=1; 
  print_leftjust(string); var=mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,cap); var; );
function print_leftjust_toggle(string,var,offstate,onstate)
  (print_leftjust_toggle(string,var,offstate,onstate,1));

function print_centerjust_toggle(string,var,onstate,offstate,cap)local(x,y,w,h,init)
  (x=gfx_x-(txt_w(string)/2);y=gfx_y;w=txt_w(string);h=gfx_texth;  
  print_centerjust(string); var=mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,cap); var; );
function print_centerjust_toggle(string,var,onstate,offstate)
  (print_centerjust_toggle(string,var,onstate,offstate,1));

function print_rightjust_toggle(string,var,onstate,offstate,cap)local(x,y,w,h,init)
  (x=gfx_x-txt_w(string);y=gfx_y;w=txt_w(string);h=gfx_texth;
  print_rightjust(string);var=mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,cap); var;  );
function print_rightjust_toggle(string,var,offstate,onstate)
  (print_rightjust_toggle(string,var,offstate,onstate,1));
  
function draw_leftjust_toggle(string,var,onstate,offstate,cap)local(x,y,w,h,init)
  (x=gfx_x;y=gfx_y;w=txt_w(string);h=gfx_texth;init=1; 
  draw_leftjust(string); var=mouse_in_rect_toggle(x,y,w,h,var,onstate,offstate,cap); var; );
function draw_leftjust_toggle(string,var,offstate,onstate)
  (draw_leftjust_toggle(string,var,offstate,onstate,1));  

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ x-on ~ sets variable to value on mouse click|
function print_leftjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x;y=gfx_y;w=txt_w(string);h=gfx_texth;init=xymask(gfx_x,gfx_y); 
  print_leftjust(string);var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function print_leftjust_xon(string,var,onstate) 
  (print_leftjust_xon(string,var,onstate,1));

function print_centerjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x-(txt_w(string)/2);y=gfx_y;w=txt_w(string);h=gfx_texth; 
  print_centerjust(string); var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function print_centerjust_xon(string,var,onstate)
  (print_centerjust_xon(string,var,onstate,1));

function print_rightjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x-txt_w(string);y=gfx_y;w=txt_w(string);h=gfx_texth; 
  print_rightjust(string); var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function print_rightjust_xon(string,var,onstate)
  (print_rightjust_xon(string,var,onstate,1));
  
function draw_leftjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x;y=gfx_y;w=txt_w(string);h=gfx_texth;init=xymask(gfx_x,gfx_y); 
  draw_leftjust(string);var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function draw_leftjust_xon(string,var,onstate) 
  (draw_leftjust_xon(string,var,onstate,1));

function draw_centerjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x-(txt_w(string)/2);y=gfx_y;w=txt_w(string);h=gfx_texth; 
  draw_centerjust(string); var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function draw_centerjust_xon(string,var,onstate)
  (draw_centerjust_xon(string,var,onstate,1));

function draw_rightjust_xon(string,var,onstate,cap)local(x,y,w,h)
  (x=gfx_x-txt_w(string);y=gfx_y;w=txt_w(string);h=gfx_texth; 
  draw_rightjust(string); var=mouse_in_rect_xon(x,y,w,h,var,onstate,cap);  var; );
function draw_rightjust_xon(string,var,onstate)
  (draw_rightjust_xon(string,var,onstate,1));  
  
/*
function print_centerjust_toggle_or_y(string,var,onstate,offstate,cap1,ystate,cap2)//local(toggle)
(
  print_centerjust(string);
  __mouse=mouse_in_rect(gfx_x-(txt_w(string)/2),gfx_y,txt_w(string),gfx_texth);
  
  !_gfx_drag && __mouse && mouse_click(cap1) ? (
  var==offstate ? var=onstate:var=offstate;   
  
  ); var;
  !_gfx_drag && __mouse && mouse_click(cap2) && this.y_var!=onstate ? this.y_var=onstate;
  var;   
);
*/ 
function print_dragable_string(string,var,inc)local(x,y,w,h)
(
  x=gfx_x;y=gfx_y;w=txt_w(string); h=gfx_texth; 
  was_not_was_drag(x,y,w,h,1);
  
    var=__drag_xaxis(var,1,inc,0);  
  //  !mouse_cap ? _gfx_drag=0;
    print_leftjust(string);
    
    var; 
);  



function __print_mouse_dblclick (cap)local(i,ii,sp)//to create a double click trigger
  (mousespeed ? sp=mousespeed: sp=6; mouse_cap==cap ? (i+=1; i==1 ? ii+=sp): (i=0; ii > 0 ? ii-=1); ii >= sp+1 ? (ii=0; 1):0;);
 
function print_leftjust_xon_dbl(string,var,onstate)
(
  print_leftjust(string);
  !_gfx_drag && mouse_in_rect(gfx_x,gfx_y,txt_w(string),gfx_texth) && __print_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
);  
function print_centerjust_xon_dbl(string,var,onstate)
(
  print_centerjust(string);
  !_gfx_drag && mouse_in_rect(gfx_x-txt_w(string)/2,gfx_y,txt_w(string),gfx_texth) && __print_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
); 
function print_rightjust_xon_dbl(string,var,onstate)
(
  print_rightjust(string);
  !_gfx_drag && mouse_in_rect(gfx_x-txt_w(string),gfx_y,txt_w(string),gfx_texth) && __print_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
); 

function __draw_mouse_dblclick (cap)local(i,ii,sp)//to create a double click trigger
  (mousespeed ? sp=mousespeed: sp=6; mouse_cap==cap ? (i+=1; i==1 ? ii+=sp): (i=0; ii > 0 ? ii-=1); ii >= sp+1 ? (ii=0; 1):0;);
 
function draw_leftjust_xon_dbl(string,var,onstate)
local(x,y)
(
  x=gfx_x;y=gfx_y;
  draw_leftjust(string);
  !_gfx_drag && mouse_in_rect(x,y,txt_w(string),gfx_texth) && __draw_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
);  
function draw_centerjust_xon_dbl(string,var,onstate)
local(x,y)
(
  x=gfx_x;y=gfx_y;
  draw_centerjust(string);
  !_gfx_drag && mouse_in_rect(x-txt_w(string)/2,y,txt_w(string),gfx_texth) && __draw_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
); 
function draw_rightjust_xon_dbl(string,var,onstate)
local(x,y)
(
  x=gfx_x;y=gfx_y;  
  draw_rightjust(string);
  !_gfx_drag && mouse_in_rect(x-txt_w(string),y,txt_w(string),gfx_texth) && __draw_mouse_dblclick (1) && var!=onstate ? var=onstate;  
  
  var;  
); 
//endf text functions

//beginf string functions
function IsStringPrefix(str,prefix)local(needle)
//returns 1 is true, 0 if false
(
  sprintf(needle=#,"%s*",prefix);
  match(needle,str) ? 1:0;
);

function BreakNewlines_NumberedStrings(str,start_strnum)local(offset,temp,i,init,breaks)
(
    i=offset=breaks=0;
    strcpy(temp=#,str);
    while( i<=strlen(str) ) (
      str_getchar(str, i)==10  || i==strlen(str) ? (
        start_strnum>=0 ? strcpy_substr(start_strnum,temp,offset,i-offset);
        offset=i+1;
        start_strnum+=1;
        breaks+=1;
      );
      i+=1;      
    );
    breaks-1;       
);

function BreakNewlines_NumberedStrings_limit(str,start_strnum,limit)local(offset,temp,i,breaks)
(
  i=offset=breaks=0;
  strcpy(temp=#,str);
  while( i<=strlen(str) && breaks<=limit) (
    str_getchar(str, i)==10 ? (
      breaks!=limit ? strcpy_substr(start_strnum,temp,offset,i-offset):
        strcpy_substr(start_strnum,temp,offset); 
      offset=i+1;
      start_strnum+=1;
      breaks+=1;
    );
    i+=1;
  );
  breaks;    
);

function FilterStringToChar(str,char)local(i,temp)
( 
  i=0;
  while( i<strlen(str) ) (
    str_getchar(str, i)==char ? ( 
      strncpy(temp=#,str,i); 
      strcpy(str,temp);  
    );
    i+=1;
  ); 
);
function FilterStringFromChar(str,char)local(i,temp)
( 
  i=0;
  while( i<strlen(str) ) (
    str_getchar(str, i)==char ? ( 
      strcpy_from(temp=#,str,i); 
      strcpy(str,temp);  
    );
    i+=1;
  ); 
);

function FilterStringToPhrase(pstr,str)
local(pi,i,found,ii,garbage,temp)
(
  pi=0;
  pl=strlen(pstr);
  loop(pl,
    stack_push(str_getchar(pstr, pi));
    pi!=pl ? pi+=1;
  );
  i=found=0;
  while( i<strlen(str) && !found) (
    str_getchar(str, i)==stack_peek(pi-1) && str_getchar(str, i+1)==stack_peek(pi-2) ? (
    ii=0;
    //testpeek=1;
    loop(pi,
      str_getchar(str, i+ii)==stack_peek(pi-1-ii) ? ii+=1;
    );
    ii==pi ? found=1; //testf=1;
    ); 
    i+=1; 
  );
  loop(pi, garbage=stack_pop(); ); //clean up stack     
  found ?  (
    strncpy(temp=#,str,i-1); 
    strcpy(str,temp);  
  );      
);

function FilterStringFromPhrase(pstr,str)
local(pi,i,found,ii,garbage,temp)
(
  pi=0;
  pl=strlen(pstr);
  loop(pl,
    stack_push(str_getchar(pstr, pi));
    pi!=pl ? pi+=1;
  );
  i=found=0;
  while( i<strlen(str) && !found) (
    str_getchar(str, i)==stack_peek(pi-1) && str_getchar(str, i+1)==stack_peek(pi-2) ? (
      ii=0;
      //testpeek=1;
      loop(pi,
        str_getchar(str, i+ii)==stack_peek(pi-1-ii) ? ii+=1;
      );
      ii==pi ? found=1; //testf=1;
    ); 
    i+=1; 
  );
  loop(pi, garbage=stack_pop(); ); //clean up stack     
  found ?  (
    strcpy_from(temp=#,str,i-1); 
    strcpy(str,temp);  
  );      
);

function FilterStringWithinBraces(str,retain_braces)local(i,temp,offset,end)
(
  i=end=offset=0;
  strcpy(temp=#,str);
  while( i<=strlen(temp) && !end ) (
    str_getchar(temp, i)==123 ? offset=i; 
    str_getchar(temp, i)==125 ? end=i+1;
    i+=1;  
  );    
  retain_braces ? strcpy_substr(str,temp,offset,end-offset):strcpy_substr(str,temp,offset+1,end-offset-2);
);
function FilterStringWithinParenthesis(str,retain_parenthesis)local(i,temp,offset,end)
(
  i=end=offset=0;
  strcpy(temp=#,str);
  while( i<=strlen(temp) && !end ) (
    str_getchar(temp, i)==40 ? offset=i; 
    str_getchar(temp, i)==41 ? end=i+1;
    i+=1;  
  );    
  retain_parenthesis ? strcpy_substr(str,temp,offset,end-offset):strcpy_substr(str,temp,offset+1,end-offset-2);
);  
function FilterStringWithinBrackets(str,retain_brackets)local(i,temp,offset,end)
(
  i=end=offset=0;
  strcpy(temp=#,str);
  while( i<=strlen(temp) && !end ) (
    str_getchar(temp, i)==91 ? offset=i; 
    str_getchar(temp, i)==93 ? end=i+1;
    i+=1;  
  );    
  retain_brackets ? strcpy_substr(str,temp,offset,end-offset):strcpy_substr(str,temp,offset+1,end-offset-2);
);

//endf string functions

//beginf scaling functions
//*clamps a var to a min and max value (example) var=min_max(var,0,10);  
function min_max(var,_min,_max)
  (var=max(_min,min(_max,var)); var;
  );//
function variable_scale(var,minval,maxval,tgtmin,tgtmax)
  (//converts a variable from one scale to another  
    tgtmin*(1-((var-(minval))/(maxval-minval))) + tgtmax*((var-(minval))/(maxval-minval)); 
  );
function variable_scale(var,minval,maxval,tgtmax)
  (//can be used if tgt min is 0 and tgtmax is positive 
    variable_scale(var,minval,maxval,0,tgtmax); 
  );
// fast rounding
function roundq(var)    local(fr)
  (   fr=var-var|0; fr>=.5 ? var+=1; var|0; );  
  
function cond_return(cond,true,false) ( cond? true:false);  
  
function cond_return(var,cond,true,false)
  ( var==cond ? true:false);  
function cond_return_less(var,cond,true,false)
  ( var<cond ? true:false); 
function cond_return_greater(var,cond,true,false)
  ( var>cond ? true:false);  
  
function img_size_h(file) local(w,h) (gfx_getimgdim(file, w, h); h);
function img_size_w(file) local(w,h) (gfx_getimgdim(file, w, h); w);

function scale_img_w(file,tgtw) (variable_scale(1,0,img_size_w(file),0,tgtw) );
function scale_img_h(file,tgth) (variable_scale(1,0,img_size_h(file),0,tgth) );

function cond_scale_img(file,cond,true,false) (  cond ? scale_img_h(file,true) : scale_img_h(file,false);  );

function scale_img_ratio(file,tgtw,tgth)
  ( min( variable_scale(1,0,img_size_w(file),tgtw), variable_scale(1,0,sh=img_size_h(file),tgth)); ); 
  

//center and scale an image at gfx_x,gfx_y to target w,h *return gfx_x, gfx_y
function center_scale_img_ratio(file,tgtw,tgth)local(_ox,_oy)
  ( 
    _ox=gfx_x;_oy=gfx_y;
    gfx_getimgdim(file, w, h);    
    s=scale_img_ratio(file,tgtw,tgth);    
    gfx_x-=.5*w*s; gfx_y-=.5*h*s;
    gfx_blit(file,scale_img_ratio(file,tgtw,tgth),0);
    _xy(_ox,_oy);
  );  
//                                                                                                     VARIABLE SCALE functions|
//endf

//beginf INDEX and MEMORY

//jsfx onnly
//is this variable defined / serialized ? if not use default, if so, return seralied value 
//function isvar(var,default)
//( !file_var(0,var) ? var=default:var=file_var(0,var);  var; );

//returns vx when i is x  - used within VX2mem loop
function v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; i==5?v=v5; i==6?v=v6; i==7?v=v7; i==8?v=v8;  i==9?v=v9; v ); 
function v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; i==5?v=v5; i==6?v=v6; i==7?v=v7; i==8?v=v8;  v );
function v_index(i,v0,v1,v2,v3,v4,v5,v6,v7)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; i==5?v=v5; i==6?v=v6; i==7?v=v7;  v );
function v_index(i,v0,v1,v2,v3,v4,v5,v6)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; i==5?v=v5; i==6?v=v6;v );
function v_index(i,v0,v1,v2,v3,v4,v5)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; i==5?v=v5; v );
function v_index(i,v0,v1,v2,v3,v4)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; i==4?v=v4; v );
function v_index(i,v0,v1,v2,v3)local(v)
( i==0?v=v0; i==1?v=v1; i==2?v=v2; i==3?v=v3; v );
function v_index(i,v0,v1,v2)local(v)
( i==0?v=v0; i==1?v=v1;  i==2?v=v2; v );
//Puts variable valuex into memlocationx
function vX2mem_range(mempos,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9)local(i)
( i=0; loop(10, mempos[i]=v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9); i+=1;); ); 
function vX2mem_range(mempos,v0,v1,v2,v3,v4,v5,v6,v7,v8)local(i)
( i=0; loop(9, mempos[i]=v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8); i+=1;); ); 
function vX2mem_range(mempos,v0,v1,v2,v3,v4,v5,v6,v7)local(i)
( i=0; loop(8, mempos[i]=v_index(i,v0,v1,v2,v3,v4,v5,v6,v7); i+=1;); ); 
function vX2mem_range(mempos,v0,v1,v2,v3,v4,v5,v6)local(i)
( i=0; loop(7, mempos[i]=v_index(i,v0,v1,v2,v3,v4,v5,v6); i+=1;); );
function vX2mem_range(mempos,v0,v1,v2,v3,v4,v5)local(i)
( i=0; loop(6, mempos[i]=v_index(i,v0,v1,v2,v3,v4,v5); i+=1;); ); 
function vX2mem_range(mempos,v0,v1,v2,v3,v4)local(i)
( i=0; loop(5, mempos[i]=v_index(i,v0,v1,v2,v3,v4); i+=1;); ); 
function vX2mem_range(mempos,v0,v1,v2,v3)local(i)
( i=0; loop(4, mempos[i]=v_index(i,v0,v1,v2,v3); i+=1;); );
function vX2mem_range(mempos,v0,v1,v2)local(i)
( i=0; loop(3, mempos[i]=v_index(i,v0,v1,v2); i+=1;); );

//list into stack
function vx_push(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9)local(i)
( i=0; loop(10, stack_push(v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9)); i+=1;); ); 
function vx_push(v0,v1,v2,v3,v4,v5,v6,v7,v8)local(i)
( i=0; loop(9, stack_push(v_index(i,v0,v1,v2,v3,v4,v5,v6,v7,v8)); i+=1;); ); 
function vx_push(v0,v1,v2,v3,v4,v5,v6,v7)local(i)
( i=0; loop(8, stack_push(v_index(i,v0,v1,v2,v3,v4,v5,v6,v7)); i+=1;); ); 
function vx_push(v0,v1,v2,v3,v4,v5,v6)local(i)
( i=0; loop(8, stack_push(v_index(i,v0,v1,v2,v3,v4,v5,v6)); i+=1;); ); 
//endf

//beginf gradients

function __backfill(x,y,w,h) local(a)
(
  a=gfx_a; setcolor(0,1); gfx_rect(x,y,w,h); gfx_a=a;
);  

function edged_grad_w(x,y,w,h,color,edgew,cntr_hl)
  (
  d=gfx_a;
  setcolor(color);
  edgew>=w/2? edgew=w/2-1;
  gfx_gradrect(x,y,edgew,h,gfx_r,gfx_g,gfx_b,0.33,0,0,0,.66*d/edgew,0,0,0,0);//left edge
  gfx_gradrect(x+w-edgew,y,edgew,h,gfx_r,gfx_g,gfx_b,1,0,0,0,-.66*d/edgew,0,0,0,0);//right edge
  gfx_gradrect(x+edgew,y,(w-edgew*2)/2,h,gfx_r,gfx_g,gfx_b,1,0,0,0,cntr_hl*d/((w-edgew*d)/2),0,0,0,0);//left half
  gfx_gradrect(x+w/2,y,1+(w-edgew*2)/2,h,gfx_r,gfx_g,gfx_b,cntr_hl+1,0,0,0,-cntr_hl*d/((w-edgew*d)/2),0,0,0,0);//right half
  );
function edged_grad_w(x,y,w,h,color,edgew,cntr_hl,cl)local(d)
  (
  cl*=w; 
  cl=max(1,cl)|0;
  d=gfx_a;
  setcolor(color);
  edgew>=w/2? edgew=w/2-1;
  
  gfx_gradrect(x,y,edgew,h,gfx_r,gfx_g,gfx_b,0.33,0,0,0,.66*d/edgew,0,0,0,0);//left edge
  gfx_gradrect(x+w-edgew,y,edgew,h,gfx_r,gfx_g,gfx_b,1,0,0,0,-.66*d/edgew,0,0,0,0);//right edge  
  gfx_gradrect(x+edgew,y,(cl-edgew),h,gfx_r,gfx_g,gfx_b,1,0,0,0,cntr_hl*d/(cl-edgew),0,0,0,0);//left half
  gfx_gradrect(x+cl,y,(w-edgew-cl),h,gfx_r,gfx_g,gfx_b,cntr_hl+1,0,0,0,-cntr_hl*d/((w-cl)-(edgew)),0,0,0,0);//right half
  );

function edged_grad_w_backfill(x,y,w,h,color,edgew,cntr_hl,cl)local(a)
  (__backfill(x,y,w,h); edged_grad_w(x,y,w,h,color,edgew,cntr_hl,cl); );
 
function edged_grad_w_backfill(x,y,w,h,color,edgew,cntr_hl) 
  (edged_grad_w_backfill(x,y,w,h,color,edgew,cntr_hl,w/2));  

function edged_grad_h(x,y,w,h,color,edgew,cntr_hl)local(d,thy,hw,bhy,bey)//cntr_hl is saturation
(
  d=gfx_a;
  setcolor(color);
  //edgew>=h/2? edgew=h/2-1;
  thy=y+edgew;//top half y
  hw=(((h-edgew*2)+1)/2)|0;//top half width
  bhy=thy+hw;//btm half y
  bey=bhy+hw;//btm edge y
  
  gfx_gradrect(x,y,w,edgew,gfx_r,gfx_g,gfx_b,.33*d,0,0,0,0,0,0,0,.66*d/edgew);//top edge
  
  gfx_gradrect(x,thy,w,hw,gfx_r,gfx_g,gfx_b,1*d,0,0,0,0,0,0,0,(cntr_hl*d/((h-edgew*2)/2)));//top half
  gfx_gradrect(x,bhy,w,hw,gfx_r,gfx_g,gfx_b,(cntr_hl+1)*d,0,0,0,0,0,0,0,-((cntr_hl*d)/((h-edgew*2)/2)));//btm half 
  
  gfx_gradrect(x,bey,w,edgew,gfx_r,gfx_g,gfx_b,1*d,0,0,0,0,0,0,0,-(.66*d/edgew));//bottom edge        
  gfx_a=d;
); 

function edged_grad_h(x,y,w,h,color,edgew,cntr_hl,cl)local(d,thy,hw,bhy,bey)
(
  cl*=h;
  cl|=0;
  //cl=max(1,cl);
  d=gfx_a;
  color != -1 ? setcolor(color);
  edgew>=h/2? edgew=h/2-1;
  thy=y+edgew;//top half y
  hw=(((h-edgew*2)+1)*cl) /2;//top half height
  bhy=thy+hw;//btm half y
  bey=bhy+hw;//btm edge y
  
  gfx_gradrect(x,y,w,edgew,gfx_r,gfx_g,gfx_b,0.33*d,0,0,0,0,0,0,0,.66*d/edgew);//top edge
  
  gfx_gradrect(x,y+edgew,w,(cl-edgew),gfx_r,gfx_g,gfx_b,1*d,0,0,0,0,0,0,0,(cntr_hl*d/(cl-edgew)));//top half
  gfx_gradrect(x,y+cl,w,(h-cl)-edgew,gfx_r,gfx_g,gfx_b,(cntr_hl+1)*d,0,0,0,0,0,0,0,-(cntr_hl*d/(h-cl-edgew)));//btm half  
    
  gfx_gradrect(x,y+h-edgew,w,edgew,gfx_r,gfx_g,gfx_b,1*d,0,0,0,0,0,0,0,-(.66*d/edgew));//bottom edge        
  gfx_a=d;
); 

function edged_grad_h_backfill(x,y,w,h,color,edgew,cntr_hl,cl)local(a)
( 
 a=gfx_a; setcolor(0,1); gfx_rect(x,y,w,h); gfx_a=a;
  edged_grad_h(x,y,w,h,color,edgew,cntr_hl,cl);
);  

function edged_grad_h_backfill(x,y,w,h,color,edgew,cntr_hl,cl) (edged_grad_h_backfill(x,y,w,h,color,edgew,cntr_hl,h/2) );

function gradient_frame(x,y,w,h,color,edge,saturation,gradient_center,thickness)local(ar,ag,ab,_oa,i)
(
  _oa=gfx_a;
  edged_grad_w(x,y+h/2,thickness,1,color,edge,saturation,gradient_center);
  gfx_a=1;
  i=0;
  loop (thickness,
    _xy(x+i,y+h/2);  
    gfx_getpixel(ar,ag,ab); gfx_r=ar; gfx_g=ag; gfx_b=ab;
    gfx_y-=1;
    gfx_lineto(x+i,y+i);
    gfx_lineto(x+w-i,y+i); 
    gfx_lineto(x+w-i,y+h-i); 
    gfx_lineto(x+i,y+h-i);
    gfx_lineto(x+i,y+(h/2)+1);
    i+=1;
  );
  gfx_a=_oa;
);

function edged_grad_h_frame(x,y,w,h,color,edge,saturation,gradient_center)local(ar,ag,ab,_oa,i)
( 
  _oa=gfx_a;
  edged_grad_h(x,y,w,h,color,edge,saturation,gradient_center);
  gfx_a=1;
  i=0;
  loop (edge,
  _xy(x+i,y+i);  
  gfx_getpixel(ar,ag,ab); gfx_r=ar; gfx_g=ag; gfx_b=ab;
  //gfx_y-=1;
  gfx_lineto(x+i,y+w-i);
  gfx_lineto(x+w-i,y+i); 
  gfx_lineto(x+w-i,y+h-i); 
  gfx_lineto(x+i,y+h-i);
  gfx_lineto(x+i,y+(h/2)+1);
  i+=1;
  );
  gfx_a=_oa;
);
//Modulated underlay

function modulated_horizontal_gradient(x,y,w,h,color,edge,saturation,gradient_center,q)local(i)
(
  q > 0 ? (  i=q;      loop(w/q,     edged_grad_h(x  ,y,i,h,color,edge,saturation,gradient_center);     i+=q;);  );
  q < 0 ? (  i=abs(q); loop(w/abs(q),edged_grad_h(x-i,y,i,h,color,edge,saturation,gradient_center);i+=abs(q););  );      
);

function modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width)
(
  modulated_horizontal_gradient(x,  y, mod_width,h,color,edge,saturation,gradient_center, q);
  modulated_horizontal_gradient(x+w,y,mod2_width,h,color,edge,saturation,gradient_center,-q);
);

function modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width)
(
  modulated_horizontal_underlay(x, y,  x2,h,color,edge,saturation,gradient_center,q, mod_width,mod2_width);
  modulated_horizontal_underlay(x2,y,w-x2,h,color,edge,saturation,gradient_center,q,mod2_width,mod3_width);
);

function modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width,x3,mod4_width)
(
  modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width);
  modulated_horizontal_underlay(x3,y, w-x3,h,color,edge,saturation,gradient_center,q,mod3_width,mod4_width);
);

function modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width,x3,mod4_width,x4,mod5_width)
(
  modulated_horizontal_underlay(x,y,w,h,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width,x3,mod4_width);
  modulated_horizontal_underlay(x4,y, w-x4,h,color,edge,saturation,gradient_center,q,mod_width4,mod5_width);
);
//endf

//beginf offscreen drawing, masking

function __toblack(buffer)local(bw,bh)
  (  gfx_dest=buffer; //gfx_setimgdim(buffer,0,0);
     gfx_getimgdim(buffer,bw,bh); setcolor(0,1); gfx_rect(0,0,bw,bh);
   );  
function __clearoffscreenbuffer(buffer)
  (   
  gfx_dest=buffer;gfx_setimgdim(buffer,-1,-1);  buffer; );
   
function __initoffscreenbuffer(buffer)
  (  __clearoffscreenbuffer(buffer); 
  gfx_dest=buffer;gfx_setimgdim(buffer,gfx_w,gfx_h);  buffer; );
 
function __initoffscreenbuffer(buffer,w,h)
  (  __clearoffscreenbuffer(buffer);  
  gfx_dest=buffer;gfx_setimgdim(buffer,w,h);   buffer; );  
  
  
function mask_guide_pink(buffer) 
  (gfx_dest=buffer; setcolor(255,0,255,1););

function showbuffer(buffer) local(w,h) (
  //gfx_dest=-1;
  //setcolor(0,1); gfx_x=gfx_y=0;
  //gfx_rect(0,0,gfx_w,gfx_h); 
  gfx_a=1;
  gfx_getimgdim(buffer,w,h);
  gfx_blit(buffer,1,0,0,0,w,h,0,0,w,h);
  );
  
function __tracebuffer(x,y,w,h,buffer,mempos)local(ix,iy,im,r,g,b,cache)instance(init)
(
cache!=gfx_w*gfx_h*256 ? init=0;
gfx_dest=buffer;
!init ? (
 ix=iy=im=0;gfx_x=x;gfx_y=y;
 
 loop (w,   
   //gfx_x=x; 
   ix=0; gfx_y=y+iy;
   loop (w,
      gfx_x=x+ix;
      gfx_getpixel(r,g,b); 
      mempos[im]=pack_rgb(r,g,b); 
      im+=1;
      ix+=1;
      );
   iy+=1;
 );
 init=1;
); 
cache=w*h*256;
im;
); 

//
function __drawtracedbuffer(x,y,w,h,buffer,mempos)local(ix,iy,im,r,g,b)
(    
  gfx_dest=buffer;    
  ix=iy=im=0;gfx_x=x;gfx_y=y;gfx_a=1;  
  loop (h,   
    gfx_x=x; ix=0; gfx_y=y+iy;
    loop (w,
      gfx_x=x+ix; // gfx_setpixel(r,g,b);  
        mempos[im] != 16711935 ? (        
          r=unpack_r(mempos[im]); g=unpack_g(mempos[im]); b=unpack_b(mempos[im]);
          gfx_setpixel(r,g,b);
      );
      im+=1; 
      ix+=1; 
    );
    iy+=1;
  );
  im; 
);  

//direction=1 is left to right, -1 right to left
function __push_rgb_loop(x,y,w,h,direction,buff)local(xpos,ypos,lo0p,r,g,b)
(  
  ypos=xpos=0;//set start variables        
  
  loop(h,//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>get loop                                                              
      xpos=0;//reset xpos 
      gfx_dest=buff;//look for pink bits in offscreen buffer       
      gfx_x=x; gfx_y=y+ypos;//set xy
      gfx_getpixel(r,g,b);//get first pixel  
      while( r!=1 || (r==1 && g!=0) || (r==1 && b!=1))//~~~~~~~~~~~~~~~~~~~~~~~~~>find loop 
           ( xpos+=1;//increment xpos
             gfx_x=max(1,x+(xpos*direction)); gfx_y=y+ypos;//set xy
             gfx_getpixel(r,g,b);//get rbg value                                                      
             xpos>=w  ? (r=1; g=0; b=1;)//break loop at w
           );//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|end find
      lo0p=xpos; xpos=0; //set lo0p to xpos, and reset xpos           
      loop( lo0p,//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>stacking loop 
            gfx_dest=-1; //search main buffer      
            gfx_x=x+(xpos*direction); gfx_y=y+ypos; //set xy  
            gfx_getpixel(r,g,b); //get pixels 
            stack_push(pack_rgb(r,g,b);); //stack packed value 
            xpos+=1; //increment xpos
           ); //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|end stacking
      stack_push(lo0p); //push loop value
      ypos+=1; //incremant ypos 
  );//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|end get loop   
 // gfx_dest=-1;   
);

//not just for round things... just goes l-r then r-l. can be used for smaller areas.
function __push_rgb_loop_radius(x,y,radius,buff)
(
  __push_rgb_loop(x-radius,y-radius,radius+1,radius*2+1, 1,buff);
  __push_rgb_loop(x+radius,y-radius,radius+1,radius*2+1,-1,buff);
);  
  

function __pop_rgb_loop(x,y,w,h,direction)local(xpos,ypos,r,g,b,l0op,pack)
(
  ypos=h-1; xpos=0;  
  loop( h,
        stack_pop(l0op);
        xpos=l0op-1;
        gfx_a=1;
        loop ( l0op,      
               stack_pop(pack);
               r=unpack_r(pack); g=unpack_g(pack); b=unpack_b(pack);
               gfx_x=x+(xpos*direction); gfx_y=y+ypos;
               gfx_setpixel(r,g,b); gfx_a != 1 ? gfx_a=1;
               xpos-=1; 
              );   
        ypos-=1; 
      );
);


function __pop_rgb_loop(x,y,radius)
(
  __pop_rgb_loop(x+radius,y-radius,radius+1,radius*2+1,-1);
  __pop_rgb_loop(x-radius,y-radius,radius+1,radius*2+1, 1);
);  

function draw_grid(w,h,xdiv,ydiv,mempos)local(x,i)
(
  x=gfx_x; y=gfx_y;
  gfx_roundrect(gfx_x,gfx_y,w,h,0);
  
  this.mem_x=mempos;
  i=1;
  loop ( xdiv ,
     gfx_line(x+(w/xdiv)*i,y,x+w/xdiv*i,y+h);
    mempos[i]=x+(w/xdiv)*i;
    i+=1;
  );
  
  this.mem_y=mempos+i;
  i=1;
  loop( ydiv ,
     gfx_line(x,y+(h/ydiv)*i,x+w,y+(h/ydiv)*i);
    mempos[mem_y+i]=y+(h/ydiv)*i;
    i+=1;
  ); 
);
 
function __grid(w,h,xdiv,ydiv,mempos)local(x,i)
(
  x=gfx_x; y=gfx_y;
 // gfx_roundrect(gfx_x,gfx_y,w,h,0);
  
  this.xmem=mempos;
  i=1;
  loop ( xdiv ,
    // gfx_line(x+(w/xdiv)*i,y,x+w/xdiv*i,y+h);
    mempos[i]=x+(w/xdiv)*i;
    i+=1;
  );
  
  this.ymem=mempos+i;
  i=1;
  loop( ydiv ,
    // gfx_line(x,y+(h/ydiv)*i,x+w,y+(h/ydiv)*i);
    mempos[xmem+i]=y+(h/ydiv)*i;
    i+=1;
  );    
  
  
   
);  

//subf (deprecated) functions

//Use push / pop corners  for grad. circles.
function __pushcorners(x,y,w,h)
local(xpos,ypos,xpos2,ypos2,r,g,b,xx,yy,lo0p,lo0p2,lside,rside,l0op,l0op2)
(
  xx=x|0; yy=y|0;
 
//set start variables  
  ypos=0; xpos=0;   ypos2=0; xpos2=0;  
  lside=max(xx,1);   
//~~~~~~~~~~~//get loop, left side//~~~~~~~~~~~// 
  loop (h, 
    xpos=0; _xy(lside,yy+ypos); gfx_getpixel(r,g,b); //reset xpos //set xy , get pixels     
    while ( r!=1 || (r==1 && g!=0) || (r==1 && b!=1))   //if it's not magenta, loop till you find it
      (xpos+=1; _xy(lside+xpos,yy+ypos); gfx_getpixel(r,g,b);
      xpos>=w? (r=1; g=0; b=1;)//force out of loop //max search
      );//just counting the spaces here
        lo0p=xpos; xpos=0; //set xpos = lo0p value //reset xpos            
    loop (lo0p,   //loop , 
      _xy(lside+xpos,yy+ypos); gfx_getpixel(r,g,b);     //set xy , get pixels 
      stack_push(r);stack_push(g);stack_push(b);     //stack values 
      xpos+=1;      //increment xpos
    );
    stack_push(lo0p);        //push loop value
    ypos+=1;      //incremant ypos  
    
  );
//~~~~~~~~~~~//get loop, right side //~~~~~~~~~~~// 
  loop (h, 
  //reset xpos //set xy , get pixels
    rside=xx+w-1;
    xpos2=0; _xy(rside,yy+ypos2); gfx_getpixel(r,g,b);  
    
  //if it's not magenta, loop till you find it 
    while ( r!=1 || (r==1 && g!=0) || (r==1 && b!=1)) (
      xpos2+=1; _xy(rside-xpos2,yy+ypos2); gfx_getpixel(r,g,b); 
      //max search
      xpos2>=w? (r=1; g=0; b=1;);
      );
      //put loops size to yposmem2 //reset xpos   
      lo0p2=xpos2; xpos2=0;      
    //loop  yposmem2 value,    
    loop (lo0p2,
    //set xy , get pixels
      _xy(rside-xpos2,yy+ypos2); gfx_getpixel(r,g,b);
    //stack values  
      stack_push(r);stack_push(g);stack_push(b);
    //increment xpos
      xpos2+=1; 
    ); //end mpos loop  
    stack_push(lo0p2);   
  //incremant ypos  
  ypos2+=1;  
  
  );
);

function __popcorners(x,y,w,h)
local(xpos,ypos,xpos2,ypos2,r,g,b,xx,yy,xposs2,lside,rside,l0op,l0op2)
( 
//set start variables 
  xx=x|0; yy=y|0; 
  ypos=0; xpos=0;   ypos2=0; xpos2=0;  
  lside=max(xx,1);
  lside=xx;
   rside=xx+w-1;
//adjust y's       
  ypos-=1; ypos2-=1;    
//~~~~~~~~~~~//draw loop, right side//~~~~~~~~~~~//
  loop (h,
    //set xpos
      stack_pop(l0op2);//mempos2[ypos2]-1;  //
      xpos2=l0op2-1;
      xposs2=0;      
      gfx_a=.75; //set alpha  for first pixel
    loop (l0op2,
    //pop values out
    
      stack_pop(b);stack_pop(g);stack_pop(r); //stack_pop();
     
    //set xy , 
    _xy(rside-xpos2+xposs2,yy+ypos2);    
    //set pixels
     gfx_setpixel(r,g,b); gfx_a !=1 ? gfx_a=1;      
    //increment xpos  
      xposs2+=1;       
    ); //end mpos loop   
    
  //de-increment ypos
    ypos2-=1;      
  );
//~~~~~~~~~~~//end draw loop, right side//~~~~~~~~~~~//    
//~~~~~~~~~~~//draw loop, left side//~~~~~~~~~~~//
  loop (h,
  stack_pop(l0op);//mempos[ypos]-1;
  xpos=l0op-1;
  gfx_a=.75; //set alpha  for first pixel
    loop (l0op,    
    //pop values out
    
      stack_pop(b);stack_pop(g);stack_pop(r); //stack_pop();
     
    //set xy , set pixels //set a to 1 after first pixel
      _xy(lside+xpos,yy+ypos); gfx_setpixel(r,g,b); gfx_a != 1 ? gfx_a=1;
    //de-increment xpos  
      xpos-=1; 
    ); //end mpos loop    
  //de-increment ypos
    ypos-=1;       
  );
//~~~~~~~~~~~//end draw loop left side//~~~~~~~~~~~// 
);

function __pushcorners(x,y,w,h,buffer)
local(xpos,ypos,xpos2,ypos2,r,g,b,xx,yy,lo0p,lo0p2,lside,rside,l0op,l0op2)
( 
//set start variables   
  xx=x|0; yy=y|0; ypos=xpos=ypos2=xpos2=0; lside=xx; rside=xx+w-1; 
//oversize the image buffer                               
  gfx_setimgdim(buffer,gfx_w+radius*2,gfx_h+radius*2);      
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//get loop left          
  loop (h,                                                           
      gfx_dest=buffer;                                                  //look for pink bits in offscreen buffer
      xpos=0;                                                           //reset xpos      
      _xy(lside,yy+ypos);                                               //set xy
      gfx_getpixel(r,g,b);                                              //get first pixel  
      while (r!=1 || (r==1 && g!=0) || (r==1 && b!=1)) (                //loop till you find pink bit
          xpos+=1;                                                          //increment xpos
          _xy(lside+xpos,yy+ypos);                                          //set xy
          gfx_getpixel(r,g,b);                                              //get rbg value
          xpos>=w? (r=1; g=0; b=1;)                                         //break loop at w
        );                                                              //
      lo0p=xpos; xpos=0;                                                //set lo0p to xpos, and reset xpos                   
      loop (lo0p,                                                       //stacking loop 
          gfx_dest=-1;                                                      //search main buffer
          _xy(lside+xpos,yy+ypos);                                          //set xy  
          gfx_getpixel(r,g,b);                                              //get pixels 
          stack_push(r);stack_push(g);stack_push(b);                        //stack values 
          xpos+=1;                                                          //increment xpos
      );                                                                //
      stack_push(lo0p);                                                 //push loop value
      ypos+=1;                                                          //incremant ypos     
  );  
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//end get loop, left
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//get loop right 
  loop (h, 
    gfx_dest=buffer;                                                    //look for pink bits in offscreen buffer  
    xpos2=0;                                                            //reset xpos //set xy , get pixels
    _xy(rside,yy+ypos2);                                                //set xy
    gfx_getpixel(r,g,b);                                                //get first pixel 
    while ( r!=1 || (r==1 && g!=0) || (r==1 && b!=1)) (                 //go till you find pink bit
        xpos2+=1;                                                           //increment xpos
        _xy(rside-xpos2,yy+ypos2);                                          //set xy 
        gfx_getpixel(r,g,b);                                                //get rbg value 
        xpos2>=w? (r=1; g=0; b=1;)                                          //break loop at w
      );                                                                //  
    lo0p2=xpos2; xpos2=0;                                               //set lo0p2 to xpos2, and reset xpos2      
    loop (lo0p2,                                                        //stacking loop
         gfx_dest=-1;                                                       //search main buffer 
        _xy(rside-xpos2,yy+ypos2);                                          //set xy 
        gfx_getpixel(r,g,b);                                                //get pixels 
        stack_push(r);stack_push(g);stack_push(b);                          //stack values 
        xpos2+=1;                                                           //increment xpos 
    );                                                                  //
    stack_push(lo0p2);                                                  //push loop value   
    ypos2+=1;                                                           //incremant ypos  
  );
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//end get loop, right  
);
//endf

//beginf Faders, Knobs, Objects
function Xbox(var)local(w,h)
(
  w=h=gfx_texth-4;
  gfx_roundrect(gfx_x,gfx_y,w,h,0,0); 
  var ? ( gfx_line(gfx_x,gfx_y,gfx_x+w,gfx_y+h);  gfx_line(gfx_x,gfx_y+w,gfx_x+w,gfx_y); );
  mouse_in_rect(gfx_x,gfx_y,w,h) && __toggle_mouseclick(1) ? (
    !var ? var=1:var=0;
  );
  gfx_x+=w+4; 
  var;  
); 
function Xbox(var,str)
(
  var=Xbox(var);draw_leftjust(str);var;
);
 



function v4.5rotation()(_global.offsetbugfix=1;);


//knob ROTATION  *includes v4.6+ hack, switch via global variable
function rotation(x,y,radius,var)
(  _global.offsetbugfix ? gfx_blit(-1,1,var,x-radius,y-radius,radius*2,radius*2,x-radius,y-radius,radius*2,radius*2);
   !_global.offsetbugfix ? gfx_blit(-1,1,var,x-radius,y-radius,radius*2,radius*2,x-radius,y-radius,radius*2,radius*2,-x+radius,-y+radius);
 );
  
  
//Pointer style function //will add more
function pointer(x,y,radius,pointer,pointercolor)
(
  _xy(x-radius+radius/10,y); 
  setcolor(pointercolor); _xy(x,y);
  pointer==0 ? gfx_circle((x+radius/1.33)|0,y,((radius/15)+.5)|0,1,1); 
  pointer==1 ? gfx_circle((x+radius/1.5)|0,y,((radius/10)+.5)|0,1,1);
  pointer==2 ? gfx_rect((x+radius/2)|0,y-((radius/14)+.5)|0,radius/2,2*((radius/16)+.5)|0);
  pointer==3 ? gfx_rect((x+radius/2-1)|0,y-((radius/14)+.5)|0,radius/2-3,min(2*((radius/16)+.5)|0,4));
  pointer==4 ? gfx_rect((x+radius/2)|0,y-((radius/14)+.5)|0,radius/2,2*((radius/8)+.5)|0);
);

function __calculate_optimal_increment(tgtinc,varmin,varmax,tgtmin,tgtmax)local(__step,__base)
(
 __base = variable_scale(0,varmin,varmax,tgtmin,tgtmax);
 __step = variable_scale(tgtinc,varmin,varmax,tgtmin,tgtmax);
 __step-__base;
);
//blits and rotates a pair of png images. knob, and pointer
function png_knob_a(var,vardefault,varmin,varmax,start,end,png0,png1,size,inc)
local(w,h,tempvalue,scale,scale2,ox,oy)
(
  ox=gfx_x; oy=gfx_y;
  gfx_getimgdim(png0, w, h); //get dimentions of base image
  size!=-1 ? scale=scale_img_h(png0,size):scale=1;//scale the image
  scale2=variable_scale(scale,0,img_size_h(png1),0,h);//scale POINTER to match base  
  _xy(gfx_x-(w*scale)/2,gfx_y-(h*scale)/2);  //set scaled xy positions    
  mouse_in_rect(gfx_x,gfx_y,(w*scale),(h*scale)) && mouse_dblclick(1) ? var=vardefault; //default var on dblclick
  tempvalue=variable_scale(var,varmin,varmax,start,end); //scale the input to a tempvalue 
  //draw and rotate image - if there is no "pointer"  (png1=-1) rotate the whole buisness. 
  png1>=0 ? (gfx_blit(png0,scale, 0); gfx_blit(png1,scale2,(tempvalue)*0.017453) ):( gfx_blit(png0,scale, (tempvalue)*0.017453) );        
  was_not_was_drag(gfx_x,gfx_y,(w*scale),(h*scale),1,9); //set drag area  
  inc=__calculate_optimal_increment(inc,varmin,varmax,start,end); //auto set increment
  tempvalue=__drag_yaxis(tempvalue,1,inc,9,inc/10,0);//mouse drag enable
  var=variable_scale(tempvalue,start,end,varmin,varmax); //scale the input back
  var=min_max(var,varmin,varmax); //clamp to min max slider var
  _xy(ox,oy);
  var; //return var
);

function png_knob_a(var,vardefault,varmin,varmax,start,end,png0,png1,size)
( png_knob_a(var,vardefault,varmin,varmax,start,end,png0,png1,size,1) );

function png_knob_a(var)local(flag,vardefault,varmin,varmax,png0,png1,start,end,w,h,tempvalue,scale,scale2)
(
  //POP values out from the stack
  stack_pop(size); 
  stack_pop(png1); 
  stack_pop(png0);
  stack_pop(end); 
  stack_pop(start);
  stack_pop(varmax); 
  stack_pop(varmin); 
  stack_pop(vardefault); 
  stack_pop(flag);
  png_knob_a(var,vardefault,varmin,varmax,start,end,png0,png1,size);  
);


function png_rotary(var,png0,png1,size,inc)
local(ox,oy,scale,scale2,w,h,tempvalue)
(
  ox=gfx_x; oy=gfx_y;
  gfx_getimgdim(png0, w, h); //get dimentions of base image
  size!=-1 ? scale=scale_img_h(png0,size):scale=1;//scale the image
  scale2=variable_scale(scale,0,img_size_h(png1),0,h);//scale POINTER to match base  
  _xy(gfx_x-(w*scale)/2,gfx_y-(h*scale)/2);  //set scaled xy positions 
  //draw and rotate image - if there is no "pointer"  (png1=-1) rotate the whole buisness. 
  tempvalue=var;
  png1>=0 ? (gfx_blit(png0,scale, 0); gfx_blit(png1,scale2,(tempvalue)*0.017453) ):( gfx_blit(png0,scale, (tempvalue)*0.017453) );        
  was_not_was_drag(gfx_x,gfx_y,(w*scale),(h*scale),1,9); //set drag area  
  //inc=__calculate_optimal_increment(inc,varmin,varmax,start,end); //auto set increment
  var=__drag_yaxis(var,1,inc,9,inc/10,0);//mouse drag enable
  _xy(ox,oy);
  var; //return var  
);



function LCD(w,h,color,edgeZ,saturation)local(_oa,x,y,txt)
(
  txt=pack_rgb(); _oa=gfx_a; x=gfx_x;y=gfx_y;
  gfx_x-=1;
  setcolor(0,.5); gfx_rect(x-1,y-1,w+3,h+3);
  setcolor(0,.25);  gfx_rect(x-2,y-2,w+4,h+4);
  gfx_a=_oa;
  edged_grad_h(x,y,w,h,color,edgeZ,saturation);
  setcolor(txt,_oa);
); 

function LCD(w,h,color) ( LCD(w,h,color,(h/12)|0,.75) ); 

function LCD(w,h,color,str)(LCD(w,h,color); gfx_y-=1; gfx_x+=w/2; print_centerjust(str););


function amp_to_db(amp) (20*log10(amp));
function db_to_amp(db) (10 ^ (db / 20));
  


function dragable_parameter_box(var,vardefault,varmin,varmax,w,h,outline)
local(bx,by,tempvalue,_cache_drag,inc)global(mouse_cap,gfx_x,gfx_y,_gfx_drag)
(
  bx=gfx_x; by=gfx_y;
  outline ? gfx_roundrect(bx,by,w,h,0,0);
  varmax-varmin!= 1 ? inc=__calculate_optimal_increment(1,varmin,varmax,0,1):inc=.01;
  mouse_in_rect(bx,by,w,h) && mouse_dblclick(1) ? var=vardefault; //default var on dblclick 
  tempvalue=variable_scale(var,varmin,varmax,0,1); //scale the input to a tempvalue  
  gfx_rect(bx,by,w*tempvalue,h);//draw rectangle
  was_not_was_drag((bx+w*tempvalue)-16,by,32,h,1,9); //set drag area
  _gfx_drag == xymask(bx+w*tempvalue-16,by) ? _cache_drag=_gfx_drag=xymask(bx,by);//cache drag mask, since location is variable (get it! ha! variable!)
  tempvalue=__drag_xaxis(tempvalue,1,inc,9,inc/10,0);//mouse drag effects tempvalue  
  _gfx_drag == _cache_drag && !mouse_cap ? _gfx_drag=_cache_drag=0;//reset masks 
  var=variable_scale(tempvalue,0,1,varmin,varmax); //scale the input back
  var=min_max(var,varmin,varmax); //clamp to min max slider var
  var; //return var
);

function dragable_parameter_box(var,vardefault,varmin,varmax,w,h)
(dragable_parameter_box(var,vardefault,varmin,varmax,w,h,0));

//set gfx_x center of fader. gfx_y to 0 value.
function v_fader(var,var_default,var_min,var_max,throw_height,cap_image,scale,rotation,RbuttonStr)
local(image_w,image_h,destx,desty,cache_y,drawx,drawy,tempdefault,tempvalue,t_value)
(
  gfx_getimgdim(cap_image,image_w,image_h);
  tempdefault=variable_scale(var_default,var_min,var_max,0,1);
  tempvalue=variable_scale(var,var_min,var_max,0,1); //scale the input to normalized tempvalue 
  drawx=gfx_x-(image_w*.5); 
  drawy=gfx_y-(tempvalue*throw_height)-image_h*.5;
  mouse_in_rect(drawx,drawy,image_w,image_h) && mouse_dblclick(1) ? tempvalue=tempdefault;
  RbuttonStr!=-1 && mouse_in_rect(drawx,drawy,image_w,image_h) && mouse_click(2) ? gfx_showmenu(Rbuttonstr);    
  gfx_blit(cap_image,scale,rotation, 0, 0, image_w, image_h, drawx, drawy, image_w, image_h); 
  _gfx_drag == _cache_drag && !mouse_cap ? _gfx_drag=_cache_drag=0;//reset masks 
  was_not_was_drag(drawx,drawy,image_w,image_h,1,9); //make drag mask
  _gfx_drag == xymask(drawx,drawy) ? (
    _cache_drag=_gfx_drag=xymask(gfx_x,gfx_y);//cache drag mask, since location is variable (get it! ha! variable!)
    _cache_y=mouse_y;
  );
  _cache_drag==xymask(gfx_x,gfx_y) && mouse_y!=_cache_y ? (
    tempvalue=variable_scale(mouse_y,gfx_y,gfx_y-throw_height,0,1);  
  );      
  varout=variable_scale(tempvalue,0,1,var_min,var_max); //scale the input back
  var=min_max(varout,var_min,var_max); //clamp to min max slider var
  var; //return var
);

function v_fader(var,var_default,var_min,var_max,throw_height,cap_image,scale,rotation)
( v_fader(var,var_default,var_min,var_max,throw_height,cap_image,scale,rotation,-1));

//set gfx_y center of fader. gfx_x to 0 value.
function h_fader(var,var_default,var_min,var_max,throw_width,cap_image,scale,rotation)
local(image_w,image_h,destx,desty,cache_y,drawx,drawy,tempdefault,tempvalue)
(
  gfx_getimgdim(cap_image,image_w,image_h);
  tempdefault=variable_scale(var_default,var_min,var_max,0,1);
  tempvalue=variable_scale(var,var_min,var_max,0,1); //scale the input to a tempvalue 
  drawx=gfx_x+(tempvalue*throw_width)-(image_w*.5); 
  drawy=gfx_y-image_h*.5;
  mouse_in_rect(drawx,drawy,image_w,image_h) && mouse_dblclick(1) ? tempvalue=tempdefault;      
  gfx_blit(cap_image,scale,rotation, 0, 0, image_w, image_h, drawx, drawy, image_w, image_h); 
  _gfx_drag == _cache_drag && !mouse_cap ? _gfx_drag=_cache_drag=0;//reset masks 
  was_not_was_drag(drawx,drawy,image_w,image_h,1,9); //make drag mask
  _gfx_drag == xymask(drawx,drawy) ? (
    _cache_drag=_gfx_drag=xymask(gfx_x,gfx_y);//cache drag mask, since location is variable (get it! ha! variable!)
    _cache_x=mouse_x;
  );
  _cache_drag==xymask(gfx_x,gfx_y) && mouse_x!=_cache_x ? (
    tempvalue=variable_scale(mouse_x,gfx_x,gfx_x+throw_width,0,1);  
  );      
  var=variable_scale(tempvalue,0,1,var_min,var_max); //scale the input back
  var=min_max(var,var_min,var_max); //clamp to min max slider var
  var; //return var
);


function rack_rails(unit_h,buffer,tmpbuffer,offset)local(rw,tmpinit,init,tmp_h,hs,ho,h1,i,hx,lo0p)
(
   rw=24;
//draw inital shape   
  !tmpinit  ? ( 
    tmp_h=gfx_h; 
    __toblack(tmpbuffer);
    __initoffscreenbuffer(tmpbuffer,rw,tmp_h); gfx_mode=2;
    edged_grad_w(0,0,rw,tmp_h,0x222222,2,1.25,.83); gfx_mode=0; tmpinit=1;
  ); 
//draw full on both sides, and re-buffer  
  buffer!=-1 && !init  || _gfx_refresh ? (
     __initoffscreenbuffer(buffer);
  // copy, rotate, stretch rail shape into buffer
    offset? lo0p=(gfx_h-(2*offset))/unit_h:lo0p=(gfx_h/unit_h)+1;  lo0p|=0;
    offset ? uh=lo0p*unit_h:uh=gfx_h;
    gfx_setimgdim(buffer,gfx_w,gfx_h);
    gfx_dest=buffer; gfx_mode=2;
    gfx_blit(tmpbuffer,1,0,   0, 0, rw, tmp_h,   offset,          offset, rw, uh, 0, 0); 
    gfx_blit(tmpbuffer,1,$pi, 0, 0, rw, tmp_h,   gfx_w-rw-offset, offset, rw, uh, 0, 0);     
    gfx_mode=0;
    //draw holes over it   
    hs=rw/6;//holesize
    ho=unit_h*.35714;//spacing of holes
    h1=(unit_h/2)-ho;//location of first hole in u
    setcolor(0,.9);
    i=0;
    loop ( lo0p, 
      hx=offset+h1+unit_h*i;
      loop(3, gfx_circle(offset+rw/2,hx,hs,1,1);hx+=ho;); i+=1;
    );     
    i=0;
    loop ( lo0p, 
      hx=offset+h1+unit_h*i;
      loop(3, gfx_circle(gfx_w-(rw/2)-offset,hx,hs,1,1);hx+=ho;); i+=1;
    );    
    init=1; 
  ); 
//redraw into main frame  
  buffer!= -1 ? (
   gfx_dest=-1;
   gfx_blit(buffer,1,0,    0, 0, gfx_w, gfx_h,     0, 0, gfx_w, gfx_h,    0, 0);  
  ); 
////reinit
  _gfx_sizecache!==return_gfxsize()  ? init=0;  
  buffer == -1 ? (
    offset? lo0p=(gfx_h-(2*offset))/unit_h:lo0p=(gfx_h/unit_h)+1;  lo0p|=0;
    offset ? uh=lo0p*unit_h:uh=gfx_h;
    gfx_setimgdim(buffer,gfx_w,gfx_h);
    gfx_dest=buffer;
    gfx_blit(tmpbuffer,1,0,   0, 0, rw, tmp_h,   offset,          offset, rw, uh, 0, 0); 
    gfx_blit(tmpbuffer,1,$pi, 0, 0, rw, tmp_h,   gfx_w-rw-offset, offset, rw, uh, 0, 0); 
    //draw holes over it   
    hs=rw/6;//holesize
    ho=unit_h*.35714;//spacing of holes
    h1=(unit_h/2)-ho;//location of first hole in u
    setcolor(0,.7);
    i=0;
    loop ( lo0p, 
      hx=offset+h1+unit_h*i;
      loop(3, 
    gfx_circle(offset+rw/2,hx,hs,1,1);
    hx+=ho;
    ); 
    i+=1;
    );     
    i=0;
    loop ( lo0p, 
    hx=offset+h1+unit_h*i;
    loop(3, 
      gfx_circle(gfx_w-(rw/2)-offset,hx,hs,1,1);
      hx+=ho;
    ); 
  i+=1;
    );   
  );  
); 

function rack_rails(unit_h,buffer,tmpbuffer)  ( rack_rails(unit_h,buffer,tmpbuffer,0) );


function __rackscrew(x,y,radius)local(_oa)
 (
  _oa=gfx_a;
//underlay shadow
  setcolor(0x242424,.03135); 
  //gfx_a=.03135;
//draw edge, backfill
  gfx_a=1; gfx_circle(x,y,(radius+1)|0,1,1);
//draw mask guide 
  mask_guide_pink(127); gfx_circle(x,y,(radius-1),0,0);    
//get surrounding pixels
  __pushcorners(x-radius,y-radius,radius*2,radius*2,127);    
//draw rectangle 
  gfx_a=.1;
  edged_grad_h(x-radius,y-radius,radius*2,radius*2,0xFFFFFF,radius/1.5,4); 
  gfx_a=.35; rotation(x,y,radius,.55);
  gfx_a=1; rotation(x,y,radius,-.34);
//redraw corners
  __popcorners(x-radius,y+radius,radius*2,radius*2); 
//slots
  setcolor(0,.6);
  gfx_rect(x-1,y-radius/2,3,radius+1);
  gfx_rect(x-radius/2,y-1,radius+1,3);  
  gfx_a=_oa
);

function rackscrews(unit_h,u,position,offset)local(rw,s,sp,mdl)
(
rw=24; 
s=6; 
sp=unit_h*.35714;

mdl=offset+(unit_h*(position-1))+(unit_h*u/2);

  __rackscrew(rw/2+offset,mdl-sp,s) ;
  __rackscrew(rw/2+offset,mdl+sp,s) ;
  __rackscrew((gfx_w-rw/2)-offset,mdl-sp,s) ;
  __rackscrew((gfx_w-rw/2)-offset,mdl+sp,s) ;
);

function __rackface_preset(color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width,mod_alpha,gradient_alpha)
(
    gfx_a=mod_alpha;
    modulated_horizontal_underlay(0,0,560,70,color,edge,saturation,gradient_center,q,mod_width,mod2_width,x2,mod3_width);
    gfx_a=gradient_alpha; edged_grad_h(0,0,560,70,color,edge,saturation,gradient_center); gfx_a=1;
    //setcolor(backfill_color,backfill);// backfill; 
);

function __rackface_preset_list(preset,color)local(color,alpha,i)
(
//__rackface_preset(color, edge, saturation, gradient_center, q, mod_width, mod2_width, x2, mod3_width, mod_alpha, gradient_alpha)
  //pack_rgb();
  //unpack_rgb(); 
  alpha=gfx_a;
  //a___color=color;
  //setcolor(color);
  //color=pack_rgb();
  i=1;
  preset==i ? __rackface_preset(color,2,1.5,.5,3,0,0,0,0,.01,alpha); i+=1;
  preset==i ? __rackface_preset(color,2,1.5,.5,3,12,80,94,12,.01,alpha); i+=1;
  preset==i ? __rackface_preset(color,4,.25,.5,2,24,0,280,24,.01,alpha); i+=1;
  preset==i ? __rackface_preset(color,4,.5,.5,2,80,94,280,80,.01,alpha); i+=1;
  
  
  preset==i ? __rackface_preset(0x565758,2,1.5,.5,3,12,80,94,12,.01,1); i+=1;
  preset==i ? __rackface_preset(0x303739,2,1.5,.5,3,12,80,94,12,.01,1); i+=1;
  preset==i ? __rackface_preset(0xB0171F,4,.25,.5,2,24,0,280,24,.01,.5); i+=1;
  preset==i ? __rackface_preset(0x121590,4,.25,.5,2,24,0,280,24,.05,1); i+=1;
  preset==i ? __rackface_preset(0xB0171F,4,.25,.5,2,24,0,280,24,.05,1); i+=1;
  preset==i ? __rackface_preset(0xB0171F,4,.25,.5,2,24,0,280,24,.05,1); i+=1;
  preset==i ? __rackface_preset(0x222222,4,.5,.5,2,80,94,280,80,.01,1); i+=1;
  preset==i ? __rackface_preset(0x444444,1,.2,.5,4,80,94,280,80,.01,1); i+=1;
  preset==i ? __rackface_preset(0x333333,1,.2,.5,4,80,94,280,80,.01,1);i+=1;
  preset==i ? __rackface_preset(0x222222,1,.2,.5,4,80,94,280,80,.01,1); i+=1;
  preset==i ? __rackface_preset(0x565758,1,.2,.5,4,80,94,280,80,.01,1); i+=1;
);

//function reinit(cond,var)

//if preset = -(x), coordinates will pull from a list defined by user (how?)
function rackface(unit_h,u,position,offset,preset,buffer,tmpbuffer)local(tmpinit,init,rx,ry,rw,presetcache,color)//instance(presetcache)
(
  color=pack_rgb();
  _gfx_sizecache!=return_gfxsize()  ? init=0;
   presetcache!=preset*position || colorcache!=pack_rgb() ? ( tmpinit=0; init=0; );
  !tmpinit  ? (   
    __initoffscreenbuffer(tmpbuffer,560,70*u); 
    __rackface_preset_list(preset,color);
    presetcache=preset*position;
    tmpinit=1;
  );
  !init ? (
    __initoffscreenbuffer(buffer);
    ry=offset+(unit_h*(position-1));
    rx=offset;
    rw=gfx_w-offset*2;
    gfx_blit(tmpbuffer,1,0, 0,0,560,70, rx,ry,rw,unit_h*u);
    init=1;
  ); 
  ry=offset+(unit_h*(position-1));
  rx=offset;
  rw=gfx_w-offset*2;
  gfx_dest=-1;
  preset != 0 ? (
    gfx_mode=2;
    gfx_blit(buffer,1,0, rx,ry,rw,unit_h*u,  rx,ry,rw+1,unit_h*u, 0,0); 
    gfx_mode=0;    
  ); 
  _gfx_sizecache=return_gfxsize();   
  colorcache=color;
);   

function outer_arc(x,y,arc_r,rotation,degf,arc_w,arc_color,var)
local(i,density,l,radff,rad0,radv,radvv,_orbg,_oa,fillrad)
( 
    _orbg=pack_rgb();  _oa=gfx_a; x|=0; y|=0;
    rad0=rotation*0.017453;     radff=(degf+rotation)*0.017453;
    arc_w<2?(density=1;l=1;); arc_w>=2?(density=.5; l=2;);
  //draw bgnd arc 
    i=0;
    loop(arc_w*l,
        gfx_arc(x,y,(arc_r)-i,rad0,radff,1);
        i+=density;        
    ); 
  //draw var-filled arc      
    setcolor(arc_color); 
    radvv=(var+rotation)*0.017453;    
    i=0;
    loop((arc_w*l),
      gfx_arc(x,y,(arc_r)-i,rad0,radvv,.99);
      i+=density;
    );    
    i=0; 
    _xy(x,y); gfx_a=_oa; setcolor(_orbg);   
);//



//use current color, x, y.
function knob_metal(var,radius,edge,shadow,saturation,color,pointer,pointercolor,rotation,hlcenter,xalpha,xrotation)
local(i,r,g,b,bcolor,x,y,a)
(
// cache values
  bcolor=pack_rgb(); x=gfx_x|0; y=gfx_y|0; //a=gfx_a;
  //rotation*=0.017453;
  hlcenter=radius*hlcenter;
  radius=min(32,radius)|0;
  a=.5;
//underlay shadow
  setcolor(0,.0314); i=16;
  shadow ? ( loop(8, gfx_circle(x,y+i-i/1.5,radius,1,1); i-=1; ); gfx_circle(x,y+1,radius+4,1,1); );  
//bezel/casing below
  setcolor(bcolor,a*2);  gfx_circle(x,y,(radius),1,1);    
//draw mask guide 
//gfx_setimgdim(127,max(gfx_w,x+radius),max(gfx_h,y+radius));
//gfx_setimgdim(127,gfx_w+radius+2,gfx_h+radius+2);

  gfx_dest=127;
  setcolor(255,0,255,1);   gfx_circle(x,y,(radius-1),0,0); 
   gfx_circle(x+1,y,(radius-1)|0,0,0);   //fudging right side
//get surrounding pixels
  //_xy(x,y); 
 // gfx_dest=-1;
 //radius+=1;
   __pushcorners(max(1,min(gfx_w-radius,x-radius)),max(1,min(gfx_h-radius,y-radius)),(radius*2),(radius*2),127);
  //radius > 32 ?  
//draw rectangle 
  //radius-=1;
gfx_dest=-1;
  setcolor(color,a);
  edged_grad_h(x-radius,y-radius,radius*2,radius*2,color,edge,saturation,hlcenter); 
//cache color for edge
  _xy(x,y-radius/2);   
  gfx_getpixel(r,g,b);   
//rotation 
//gfx_dest=-1;
 gfx_a=xalpha; 
 rotation(x,y,radius,xrotation);//X rotate underlay "blur" alpha
 gfx_a=1;
 rotation(x,y,radius,rotation);// rotatate underlay full alpha
 rotation(x,y,radius,-var);// offset rotation from pointer variable 
//do pointer
  gfx_a=.9;
  pointer(x,y,radius,pointer,pointercolor);
//POINTER ROTATION  
  gfx_a=1;
  rotation(x,y,radius,var);
//redraw corners
  //radius+=1;
   __popcorners(x-radius,y+radius,(radius*2),radius*2);    
  //radius-=1; 
//outline / edging                                               
  gfx_r=r;gfx_g=g;gfx_b=b;gfx_a=a/2;
  _xy(x,y); 
  i=1;
  loop (9, gfx_circle(x,y,(radius-i),0,1); i-=.15; );
  gfx_a=a/8;gfx_circle(x,y,radius-1,0,1);
  gfx_a=a/4;gfx_circle(x,y,radius-.5,0,1);  
  gfx_a=a/2;gfx_circle(x,y,radius,0,1);
 // gfx_a=a;gfx_circle(x,y,radius,0,1);
  setcolor(0,.1); gfx_circle(x,y,radius-.5,0,1); 
  setcolor(0xFFFFFF,.07125); gfx_circle(x,y,radius-1.5,0,1); 
  setcolor(0xFFFFFF,.035);gfx_circle(x,y,radius-2,0,1); 
  setcolor(0xFFFFFF,.0125);gfx_circle(x,y,radius+.5,0,1); 
  setcolor(0x0,.025);gfx_circle(x,y,radius+1,0,1);    
  //reset color
  setcolor(bcolor,a); _xy(x,y); 
);

//function fader(var,throw_height,bg_img,cap_img) 

/* NOT FUNCTIONAL
function knob_m(var)
(
  stack_pop(xrotation); stack_pop(xalpha);stack_pop(hlcenter);stack_pop(rotation);stack_pop(pointercolor);
  stack_pop(pointer);stack_pop(color);stack_pop(saturation);stack_pop(shadow);stack_pop(edge);stack_pop(radius);
  stack_pop(end); stack_pop(start); stack_pop(varmax); stack_pop(varmin); stack_pop(vardefault); stack_pop(flag);
  knob_metal(var,radius,edge,shadow,saturation,color,pointer,pointercolor,rotation,hlcenter,xalpha,xrotation);
  
  mouse_in_rect(gfx_x-radius,gfx_y-radius,radius*2,radius*2) && mouse_dblclick(1) ? var=vardefault; //default var on dblclick 
  tempvalue=variable_scale(var,varmin,varmax,start,end); //scale the input to a tempvalue
  //draw and rotate image - if there is no "pointer"  (png1=-1) rotate the whole buisness.
        
  was_not_was_drag(gfx_x-radius,gfx_y-radius,radius*2,radius*2,1,9); //set drag area
  tempvalue=drag_yaxis(tempvalue,xymask(gfx_x,gfx_y),1,6,9,.6,0);//mouse drag effects tempvalue
  var=variable_scale(tempvalue,start,end,varmin,varmax); //scale the input back
  var=min_max(var,varmin,varmax); //clamp to min max slider var
  var; //return var
  
);  
  */ 
  
/* 
function rectstyles(rectstyle,x,y,boxw,boxh,boxr,boxg,boxb,gradstring)
local(_oa,radius,ol)
(
_oa=gfx_a;
rectstyle >= 300 ?  (
  ol=.5;
  rectstyle < 700 ? ol=1;
  rectstyle < 600 ? ol=1.25;
  rectstyle < 500 ? ol=1.50;
  rectstyle < 400 ? ol=1.75;
  );
rectstyle == 0 ? gfx_roundrect(x,y,boxw,boxh,0);
  rectstyle >=1 && rectstyle < 100 ? (
    radius=rectstyle;
    gfx_roundrect(x,y,boxw,boxh,radius);
  );
  rectstyle == 100 ? gfx_rect(x,y,boxw,boxh);
  rectstyle > 100 && rectstyle < 200 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,radius);
  );
  rectstyle >= 200 && rectstyle < 300 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill_grad(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,gradstring,radius)  
  );
  rectstyle >=300 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill_grad(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,gradstring,radius);
    setcolor(boxr*ol,boxg*ol,boxb*ol); 
    gfx_a=1; gfx_roundrect(x,y,boxw,boxh,radius,1); 
    //gfx_a=.5; gfx_roundrect(x,y,boxw,boxh,radius,1); 
  );
gfx_a=_oa;  
radius; // return radius (for higlight, etc...)
);

function rectstyles(rectstyle,x,y,boxw,boxh,boxr,boxg,boxb,gradstring,graddiv)
local(_oa,radius,ol)
(
_oa=gfx_a;
rectstyle >= 300 ?  (
  ol=.5;
  rectstyle < 700 ? ol=1;
  rectstyle < 600 ? ol=1.25;
  rectstyle < 500 ? ol=1.50;
  rectstyle < 400 ? ol=1.75;
  );
rectstyle == 0 ? gfx_roundrect(x,y,boxw,boxh,0);
  rectstyle >=1 && rectstyle < 100 ? (
    radius=rectstyle;
    gfx_roundrect(x,y,boxw,boxh,radius);
  );
  rectstyle == 100 ? gfx_rect(x,y,boxw,boxh);
  rectstyle > 100 && rectstyle < 200 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,radius);
  );
  rectstyle >= 200 && rectstyle < 300 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill_grad(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,gradstring,radius,graddiv)  
  );
  rectstyle >=300 ? (
    radius=rectstyle%100;
    gfx_roundrect_fill_grad(x,y,boxw,boxh,boxr,boxg,boxb,gfx_a,gradstring,radius,graddiv);
    setcolor(boxr*ol,boxg*ol,boxb*ol); 
    gfx_a=1; gfx_roundrect(x,y,boxw,boxh,radius,1); 
    //gfx_a=.5; gfx_roundrect(x,y,boxw,boxh,radius,1); 
  );
gfx_a=_oa;  
radius; // return radius (for higlight, etc...)
);

function _parameter_box(x,y,boxw,boxh,boxr,boxg,boxb,txtr,txtg,txtb,var,rectstyle,gradstring)//,maxval,defaultval,minval,str_format)
local (range, reset, setX, strw, was_mouse, drawval)//instance(drawpos,drawvv,valuefff) 
(   
  x+y*256==was_mouse && mouse_cap == 1 ? 
    var=((max(0,min(mouse_x-x,boxw)))/boxw); 
  drawval=boxw*var;  
  setcolor(boxr,boxg,boxb); //set box color
  radius=rectstyles(rectstyle,x,y,max(2,drawval),boxh,boxr,boxg,boxb,gradstring,boxw);
  was_mouse == 0 && mouse_in_rect(x+drawval-16, y, 32 ,boxh) ? was_mouse=x+y*256; 
  was_mouse==x+y*256 ? (
    //setcolor(valr,valg,valb,1);
     setcolor(boxr*2,boxg*2,boxb*2,1);
    gfx_roundrect(x+1,y+1,max(2,drawval-2),boxh-2,radius,1);
  );//draw mouse - on highlight    
  !mouse_cap&3 ? was_mouse=0;  
  setcolor(valr,varg,valb,1);//set the text color
  gfx_y=y;   
  gfx_x=x+drawval;
  var;
);   
 
 
